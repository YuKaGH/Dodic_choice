<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивный додекаэдр</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
        }
        
        #container { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #selected-face {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        button {
            background: #4a6fa5;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5a7fb5;
        }
        
        h3 {
            margin-top: 0;
            color: #ffd700;
        }
        
        .highlight {
            color: #ffd700;
            font-weight: bold;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
</head>
<body>
    <div id="container"></div>
    
    <div id="info">
        <h3>Додекаэдр</h3>
        <p><span class="highlight">Вращение:</span> зажмите ЛКМ и двигайте мышь</p>
        <p><span class="highlight">Приближение:</span> колесико мыши</p>
        <p><span class="highlight">Выбор грани:</span> двойной клик ЛКМ по номеру</p>
        <p><span class="highlight">Сброс камеры:</span> кнопка ниже</p>
    </div>
    
    <div id="selected-face">
        <div>Грань</div>
        <div id="face-number">-</div>
    </div>
    
    <div id="controls">
        <button onclick="resetCamera()">Сброс камеры</button>
        <button onclick="toggleRotation()">Вращение: <span id="rotation-status">ВКЛ</span></button>
        <button onclick="toggleEdges()">Рёбра: <span id="edges-status">ВКЛ</span></button>
        <button onclick="changeDodecahedronStyle()">Стиль: <span id="style-status">Прозрачный</span></button>
    </div>

    <script>
        // Данные додекаэдра
        const phi = (1 + Math.sqrt(5)) / 2; // Золотое сечение
        
        // Вершины додекаэдра (0-индексация)
        const vertices = [
            [1, 1, 1],          // 0
            [1, 1, -1],         // 1
            [1, -1, 1],         // 2
            [1, -1, -1],        // 3
            [-1, 1, 1],         // 4
            [-1, 1, -1],        // 5
            [-1, -1, 1],        // 6
            [-1, -1, -1],       // 7
            [0, phi, 1/phi],    // 8
            [0, phi, -1/phi],   // 9
            [0, -phi, 1/phi],   // 10
            [0, -phi, -1/phi],  // 11
            [1/phi, 0, phi],    // 12
            [1/phi, 0, -phi],   // 13
            [-1/phi, 0, phi],   // 14
            [-1/phi, 0, -phi],  // 15
            [phi, 1/phi, 0],    // 16
            [phi, -1/phi, 0],   // 17
            [-phi, 1/phi, 0],   // 18
            [-phi, -1/phi, 0]   // 19
        ];
        
        // Грани додекаэдра (номера вершин, 0-индексация) - уже в правильном порядке обхода
        const faces = [
            [0, 16, 1, 9, 8],       // Грань 1  [0, 8, 1, 16, 9]
            [0, 12, 2, 17, 16],     // Грань 2
            [0, 8, 4,  14,12],      // Грань 3 [0, 4, 8, 12, 14]
            [1, 16, 17, 3, 13],     // Грань 4 [1, 3, 13, 16, 17]
            [1, 9, 5,  15,13],      // Грань 5  [1, 5, 9, 13, 15]
            [2,10, 11, 3,17],     // Грань 6  [2, 3, 10, 11, 17]
            [2,12, 14, 6, 10],     // Грань 7[2, 6, 10, 12, 14]
            [3, 11, 7,15, 13],     // Грань 8  [3, 7, 11, 13, 15]
            [4, 18, 5, 9, 8],       // Грань 9 [4, 5, 8, 9, 18]
            [4, 14, 6,19, 18],     // Грань 10[4, 6, 14, 18, 19]
            [5, 18, 19,7, 15],     // Грань 11[5, 7, 15, 18, 19]
            [6, 10, 11, 7,19]      // Грань 12 [6, 7, 10, 11, 19]
        ];

        // Центры граней (нормали)
        const faceCenters = [
            [0.7236, 1.1708, 0.0000],    // Центр грани 1
            [1.1708, 0.0000, 0.7236],    // Центр грани 2
            [0.0000, 0.7236, 1.1708],    // Центр грани 3
            [1.1708, 0.0000, -0.7236],   // Центр грани 4
            [0.0000, 0.7236, -1.1708],   // Центр грани 5
            [0.7236, -1.1708, 0.0000],   // Центр грани 6
            [0.0000, -0.7236, 1.1708],   // Центр грани 7
            [0.0000, -0.7236, -1.1708],  // Центр грани 8
            [-0.7236, 1.1708, 0.0000],   // Центр грани 9
            [-1.1708, 0.0000, 0.7236],   // Центр грани 10
            [-1.1708, 0.0000, -0.7236],  // Центр грани 11
            [-0.7236, -1.1708, 0.0000]   // Центр грани 12
        ];
        
        // Сцена
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        
        // Камера
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 8, 8);
        
        // Рендерер
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Управление камерой
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        
        // Освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);
        
        // Группа для додекаэдра и его номеров граней
        const dodecahedronGroup = new THREE.Group();
        scene.add(dodecahedronGroup);
        
        // Создание геометрии додекаэдра с правильной разбивкой на треугольники
        const geometry = new THREE.BufferGeometry();
        
        // Создаем массив вершин и индексов для треугольников
        const positions = [];
        const indices = [];
        
        // Для каждой грани создаем треугольники: (0,1,2), (0,2,3), (0,3,4)
        // Это правильное разбиение пятиугольника на треугольники
        faces.forEach((face, faceIndex) => {
            // Добавляем вершины грани
            const vertexIndices = [];
            face.forEach(vertexIdx => {
                const vertex = vertices[vertexIdx];
                positions.push(vertex[0], vertex[1], vertex[2]);
                vertexIndices.push(positions.length / 3 - 1);
            });
            
            // ПРАВИЛЬНОЕ разбиение пятиугольника на треугольники
            // Треугольник 1: (0,1,2)
            indices.push(vertexIndices[0], vertexIndices[1], vertexIndices[2]);
            // Треугольник 2: (0,2,3)
            indices.push(vertexIndices[0], vertexIndices[2], vertexIndices[3]);
            // Треугольник 3: (0,3,4)
            indices.push(vertexIndices[0], vertexIndices[3], vertexIndices[4]);
        });
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        
        // Материал для додекаэдра - полупрозрачный голубой (как в index.html)
        const material = new THREE.MeshPhongMaterial({
            color: 0x1565c0,
            emissive: 0x0a0e14,
            shininess: 100,
            transparent: true,
            opacity: 0.7,
            specular: 0x444444,
            side: THREE.DoubleSide
        });
        
        // Создаем меш додекаэдра
        const dodecahedron = new THREE.Mesh(geometry, material);
        dodecahedronGroup.add(dodecahedron);
        
        // ==== СОЗДАНИЕ РЁБЕР ДОДЕКАЭДРА ====
        // Сначала находим все уникальные рёбра
        function getEdgesFromFaces() {
            const edgeSet = new Set();
            const edges = [];
            
            faces.forEach(face => {
                for (let i = 0; i < face.length; i++) {
                    const v1 = face[i];
                    const v2 = face[(i + 1) % face.length];
                    
                    // Создаем уникальный ключ для ребра (упорядоченная пара)
                    const key = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;
                    
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        edges.push([v1, v2]);
                    }
                }
            });
            
            return edges;
        }
        
        // Создание золотых рёбер
        function createGoldenEdges() {
            const edges = getEdgesFromFaces();
            const edgeGeometry = new THREE.BufferGeometry();
            const edgePositions = [];
            
            // Собираем все позиции рёбер
            edges.forEach(edge => {
                const v1 = vertices[edge[0]];
                const v2 = vertices[edge[1]];
                
                // Добавляем координаты начала и конца ребра
                edgePositions.push(
                    v1[0], v1[1], v1[2],  // Начало ребра
                    v2[0], v2[1], v2[2]   // Конец ребра
                );
            });
            
            edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edgePositions, 3));
            
            // Материал для рёбер - золотой, с эффектом свечения
            const edgeMaterial = new THREE.LineBasicMaterial({
                color: 0xffd700,
                linewidth: 2.5,
                transparent: true,
                opacity: 0.9
            });
            
            // Создаём линии для рёбер
            const edgesMesh = new THREE.LineSegments(edgeGeometry, edgeMaterial);
            
            // Слегка увеличиваем рёбра, чтобы они были поверх граней
            edgesMesh.scale.set(1.001, 1.001, 1.001);
            
            return edgesMesh;
        }
        
        // Создаём и добавляем рёбра
        let edgesMesh = createGoldenEdges();
        dodecahedronGroup.add(edgesMesh);
        
        // Флаг для отображения рёбер
        let showEdges = true;
        
        // Массив для хранения текстовых мешей (будут прикреплены к граням)
        const textMeshes = [];
        
        // Создаем текстовые меши для каждой грани с новым дизайном
        faces.forEach((face, faceIndex) => {
            const center = faceCenters[faceIndex];
            
            // Создаем canvas для текста
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Уменьшаем размер canvas в два раза
            canvas.width = 256;
            canvas.height = 256;
            
            // Очищаем canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Рисуем темно-синий круг (уменьшенный в два раза)
            context.beginPath();
            context.arc(128, 128, 90, 0, Math.PI * 2); // Радиус 90 вместо 180
            
            // Темно-синий фон круга
            context.fillStyle = 'rgba(25, 25, 112, 0.9)'; // Темно-синий
            context.fill();
            
            // Золотая окантовка круга (толщина увеличена для лучшей видимости)
            context.lineWidth = 6;
            context.strokeStyle = '#ffd700'; // Золотой цвет
            context.stroke();
            
            // Рисуем ярко-желтый текст
            context.font = 'bold 100px Arial'; // Шрифт уменьшен в два раза
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = '#ffff00'; // Ярко-желтый цвет
            context.fillText((faceIndex + 1).toString(), 128, 128);
            
            // Создаем текстуру из canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            // Создаем плоскую геометрию для текста (уменьшенную в два раза)
            const textGeometry = new THREE.CircleGeometry(0.6, 32); // Радиус 0.6 вместо 1.2
            
            // Материал для текста
            const textMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
                alphaTest: 0.1
            });
            
            // Создаем меш для текста
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            
            // Позиционируем текст в центре грани
            const centerVec = new THREE.Vector3(center[0], center[1], center[2]);
            const normal = centerVec.clone().normalize();
            
            // Позиция текста - немного выдвинута от центра грани
            const textPosition = centerVec.clone().multiplyScalar(1.01);
            textMesh.position.copy(textPosition);
            
            // Ориентируем текст так, чтобы он смотрел в направлении нормали грани
            textMesh.lookAt(centerVec.clone().add(normal));
            
            // Сохраняем индекс грани в пользовательских данных
            textMesh.userData.faceIndex = faceIndex + 1;
            textMesh.userData.url = `https://example.com/page${faceIndex + 1}`;
            
            // Добавляем текст в группу додекаэдра
            dodecahedronGroup.add(textMesh);
            textMeshes.push(textMesh);
        });
        
        // Raycaster для определения кликов
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Переменные для обработки двойного клика
        let clickCount = 0;
        let clickTimer = null;
        
        // Обработчик кликов
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Обновляем луч
            raycaster.setFromCamera(mouse, camera);
            
            // Проверяем пересечение с текстовыми мешами
            const intersects = raycaster.intersectObjects(textMeshes);
            
            if (intersects.length > 0) {
                clickCount++;
                
                if (clickCount === 1) {
                    clickTimer = setTimeout(() => {
                        clickCount = 0;
                    }, 300);
                } else if (clickCount === 2) {
                    clearTimeout(clickTimer);
                    clickCount = 0;
                    
                    // Нашли грань!
                    const faceNumber = intersects[0].object.userData.faceIndex;
                    document.getElementById('face-number').textContent = faceNumber;
                    
                    // Анимация выделения
                    highlightFace(faceNumber);
                }
            }
        }
        
        // Функция для подсветки выбранной грани
        function highlightFace(faceNumber) {
            const faceIndex = faceNumber - 1;
            const center = faceCenters[faceIndex];
            
            // Создаем сферу для подсветки
            const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 0.7
            });
            
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            
            // Позиционируем сферу в центре грани
            const centerVec = new THREE.Vector3(center[0], center[1], center[2]);
            sphere.position.copy(centerVec);
            
            dodecahedronGroup.add(sphere);
            
            // Удаляем сферу через 1 секунду
            setTimeout(() => {
                dodecahedronGroup.remove(sphere);
            }, 1000);
        }
        
        // Функция включения/выключения рёбер
        function toggleEdges() {
            showEdges = !showEdges;
            edgesMesh.visible = showEdges;
            document.getElementById('edges-status').textContent = showEdges ? 'ВКЛ' : 'ВЫКЛ';
        }
        
        // Переменная для отслеживания стиля додекаэдра
        let isTransparent = true;
        
        // Функция изменения стиля додекаэдра
        function changeDodecahedronStyle() {
            isTransparent = !isTransparent;
            
            if (isTransparent) {
                // Полупрозрачный стиль (как в index.html)
                dodecahedron.material.color.setHex(0x1565c0);
                dodecahedron.material.emissive.setHex(0x0a0e14);
                dodecahedron.material.opacity = 0.7;
                dodecahedron.material.transparent = true;
                document.getElementById('style-status').textContent = 'Прозрачный';
            } else {
                // Непрозрачный стиль
                dodecahedron.material.color.setHex(0x2a4a7a);
                dodecahedron.material.emissive.setHex(0x000000);
                dodecahedron.material.opacity = 1.0;
                dodecahedron.material.transparent = false;
                document.getElementById('style-status').textContent = 'Непрозрачный';
            }
            
            dodecahedron.material.needsUpdate = true;
        }
        
        // Обработчик изменения размера окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Функция сброса камеры
        function resetCamera() {
            controls.reset();
            camera.position.set(8, 8, 8);
            controls.update();
        }
        
        // Функция включения/выключения вращения
        let autoRotate = true;
        function toggleRotation() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            document.getElementById('rotation-status').textContent = autoRotate ? 'ВКЛ' : 'ВЫКЛ';
        }
        
        // Настройка автовращения
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        
        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                // Вращаем всю группу (додекаэдр и номера граней вместе)
                dodecahedronGroup.rotation.y += 0.002;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Добавляем обработчики событий
        window.addEventListener('click', onMouseClick);
        window.addEventListener('dblclick', onMouseClick);
        window.addEventListener('resize', onWindowResize);
        
        // Запускаем анимацию
        animate();
        
        // Информация о количестве граней
        console.log(`\nДодекаэдр создан. Количество граней: ${faces.length}`);
        console.log(`Геометрия: ${positions.length/3} вершин, ${indices.length/3} треугольников`);
    </script>
</body>
</html>